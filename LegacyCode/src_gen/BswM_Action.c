/******************************************************************************
 *
 *                          Copyright 2021 Siemens
 *                           All Rights Reserved
 *
 * THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS
 * THE PROPERTY OF SIEMENS OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
 *
 ******************************************************************************
 *
 * This file is automatically generated by VSC.
 * Do not edit manually!
 * VSC Version:  2.6.8
 * BswMPlugin:   com.mentor.bsw.bswm.generator 5.18.0
 *
 ******************************************************************************
 *
 * Module:       BswM
 *
 * File Name:    BswM_Action.c
 *
 * Description:  Contains implementation of internally used, action handling functions.
 *
 ******************************************************************************/

/* VSTAR_BSW_LCFG_SOURCE guard must NOT be applied here to allow initialitazion
 * of other Post-Build BSW modules from UserCallout actions, see: Bug44120 */
#define BSWM_BSW_LCFG_SOURCE
#define BSWM_INTERNAL_LCFG_SYMBOL_EXPORT_NEEDED
#define BSWM_USER_INCLUDE_FILE_EXPORT_NEEDED

/*=============================== INCLUSIONS =================================*/

#include "BswM_Private.h"

/*============================== VERSION CHECK ===============================*/

#if((BSWM_ACTION_SW_MAJOR_VERSION != BSWM_SW_MAJOR_VERSION) || \
    (BSWM_ACTION_SW_MINOR_VERSION != BSWM_SW_MINOR_VERSION) || \
    (BSWM_ACTION_SW_PATCH_VERSION != BSWM_SW_PATCH_VERSION))
#   error "The software version of the BSWM_ACTION header file does not match the expected version!"
#endif

/*============================ MACRO DEFINITIONS =============================*/

/*====================== INTERNAL VARIABLE DEFINITIONS =======================*/

/*====================== INTERNAL FUNCTION DECLARATIONS ======================*/

/*====================== EXTERNAL VARIABLE DEFINITIONS =======================*/

/*====================== EXTERNAL FUNCTION DEFINITIONS =======================*/

#define BSWM_START_SEC_CODE
#include "BswM_MemMap.h"

#define BSWM_STOP_SEC_CODE
#include "BswM_MemMap.h"


#define BSWM_START_SEC_CODE
#include "BswM_MemMap.h"

FUNC(boolean, BSWM_CODE) BswM_SchMSwitch_Action_StartupOne(
        CONSTP2CONST(BswM_ActionListItemType, AUTOMATIC, BSWM_CONST) ptrActionListItem
)
{
    /* Return value indicating if Action with AbortOnFail set to True has failed */
    VAR(boolean, AUTOMATIC) actionFailed;
    /* Result of the external function call of the action */
    VAR(Std_ReturnType, AUTOMATIC) stdCallResult;

    /* [VSTAR_BSWM-90899] BswMSchMSwitch */
    stdCallResult = SchM_Switch_BswM_EcuMode((uint8)RTE_MODE_BswM_StateType_BSWM_STATE_STARTUP_TWO);

    /* [VSTAR_BSWM-90311] Determine if the Action failed or not */
    actionFailed = (stdCallResult != SCHM_E_OK) ? TRUE : FALSE;

    return actionFailed;
}

FUNC(boolean, BSWM_CODE) BswM_SchMSwitch_Action_Run(
        CONSTP2CONST(BswM_ActionListItemType, AUTOMATIC, BSWM_CONST) ptrActionListItem
)
{
    /* Return value indicating if Action with AbortOnFail set to True has failed */
    VAR(boolean, AUTOMATIC) actionFailed;
    /* Result of the external function call of the action */
    VAR(Std_ReturnType, AUTOMATIC) stdCallResult;

    /* [VSTAR_BSWM-90899] BswMSchMSwitch */
    stdCallResult = SchM_Switch_BswM_EcuMode((uint8)RTE_MODE_BswM_StateType_BSWM_STATE_RUN);

    /* [VSTAR_BSWM-90311] Determine if the Action failed or not */
    actionFailed = (stdCallResult != SCHM_E_OK) ? TRUE : FALSE;

    return actionFailed;
}

FUNC(boolean, BSWM_CODE) BswM_UserCallout_Action_RteStart(
        CONSTP2CONST(BswM_ActionListItemType, AUTOMATIC, BSWM_CONST) ptrActionListItem
)
{
    /* [SWS_BSWM-00039] [SWS_BSWM-00040] [SWS_BSWM-00054] [VSTAR_BSWM-90834] */
    (void) Rte_Start();
    /* This action cannot fail */
    return FALSE;
}

/**
 * [SWS_BSWM-00017] An ActionList contains a set of actions.
 * [SWS_BSWM-00018] An ActionList may contain other ActionLists.
 * [SWS_BSWM-00019] An ActionList may contain Rules.
 * [SWS_BSWM-00062] [SWS_BSWM-00067] ActionList of a nested Rule shall be evaluated before the next ActionListItem.
 * [SWS_BSWM-00037.v2] The ActionList structure shall handle at least 7 hierarchic levels.
 * [SWS_BSWM-00223.v2] The same ActionList can be executed multiple times.
 */
FUNC(boolean, BSWM_CODE) BswM_ActionList(
        CONSTP2CONST(BswM_ActionListType, AUTOMATIC, BSWM_CONST) ptrActionList
)
{
    /* Index of the current Item of the ActionList */
    VAR(uint8, AUTOMATIC) itemIndex;
    /* Indicates if ActionList has failed */
    VAR(boolean, AUTOMATIC) actionListFailed = FALSE;

    for (itemIndex = 0U; itemIndex < ptrActionList->itemsTotalCount; itemIndex++)
    {
        /* Indicates if an ActionListItem has failed */
        VAR(boolean, AUTOMATIC) itemFailed;
        /* Pointer to current ActionListItem */
        CONSTP2CONST(BswM_ActionListItemType, AUTOMATIC, BSWM_CONST) ptrActionListItem = &ptrActionList->ptrActionListItems[itemIndex];
        /* Referenced index from the ActionListItem. It is the index of the Action/Rule/ActionList */
        VAR(BswM_IdType, AUTOMATIC) refIndex = ptrActionListItem->elementIndex;

        switch(ptrActionListItem->type)
        {
            case BSWM_ACTION:
            {
                itemFailed = BswM_ActionsArray[refIndex](ptrActionListItem);
                break;
            }
            case BSWM_RULE:
            {
                itemFailed = BswM_RuleProperties[refIndex].ruleFunction(NULL_PTR);
                break;
            }
            case BSWM_ACTIONLIST:
            {
                CONSTP2CONST(BswM_ActionListType, AUTOMATIC, BSWM_CONST) ptrNextActionList = &BswM_PBcfgPtr->ptrAllActionLists[refIndex];
                /* KW MISRA.FUNC.RECUR VIOLATION Recursion depends on configuration, but maximum level is ensured by generator CCs */
                itemFailed = BswM_ActionList(ptrNextActionList);
                break;
            }
            default: /* Do Nothing */
            {
                itemFailed = FALSE;
                break;
            }
        }

        /* [SWS_BSWM-00055.v2-01] [SWS_BSWM-00055.v2-02] [SWS_BSWM-00055.v2-03]
         * Abort ActionList execution if the ActionListItem has failed and BswMAbortOnFail is configured True. */
        if((itemFailed == TRUE) && (ptrActionListItem->hasAbortOnFail == TRUE))
        {
            actionListFailed = TRUE;
            break;
        }
    }
    return actionListFailed;
}

#define BSWM_STOP_SEC_CODE
#include "BswM_MemMap.h"


/*====================== INTERNAL FUNCTION DEFINITIONS =======================*/

/*======================== END OF FILE BswM_Action.c =========================*/
